// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Parses a policy set from a Cedar policy string into JSON.
@ffi.Native<CCedarPolicySetResult Function(ffi.Pointer<ffi.Char>)>(isLeaf: true)
external CCedarPolicySetResult cedar_parse_policy_set(
  ffi.Pointer<ffi.Char> policies,
);

/// Links a policy template to a set of entities.
///
/// Returns the linked policy template in JSON format.
@ffi.Native<
    ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>(isLeaf: true)
external ffi.Pointer<ffi.Char> cedar_link_policy_template(
  ffi.Pointer<ffi.Char> policy_template_json,
  ffi.Pointer<ffi.Char> entities_json,
);

/// Initializes the Cedar policy engine with the given configuration.
///
/// This must be called exactly once before any other Cedar functions are called.
@ffi.Native<CInitResult Function(ffi.Pointer<CCedarConfig>)>(isLeaf: true)
external CInitResult cedar_init(
  ffi.Pointer<CCedarConfig> config,
);

/// De-initializes the Cedar policy engine.
///
/// This must be called exactly once when the Cedar policy engine is no longer needed.
@ffi.Native<ffi.Void Function(ffi.Pointer<CedarStore>)>(isLeaf: true)
external void cedar_deinit(
  ffi.Pointer<CedarStore> store,
);

/// Performs a Cedar authorization check.
///
/// This must be called after [cedar_init] has been called.
@ffi.Native<
    CAuthorizationDecision Function(
        ffi.Pointer<CedarStore>, ffi.Pointer<CCedarQuery>)>(isLeaf: true)
external CAuthorizationDecision cedar_is_authorized(
  ffi.Pointer<CedarStore> store,
  ffi.Pointer<CCedarQuery> query,
);

final class CedarStore extends ffi.Opaque {}

/// The result of parsing policies from a Cedar policy string into JSON
/// via [cedar_parse_policies].
final class CCedarPolicySetResult extends ffi.Struct {
  /// The length of the `policy_set_json` string.
  @ffi.UintPtr()
  external int policy_set_json_len;

  /// The policy set in JSON format.
  ///
  /// This is only valid if `errors` is null.
  external ffi.Pointer<ffi.Char> policy_set_json;

  /// The number of errors encountered while parsing the policy set.
  @ffi.UintPtr()
  external int errors_len;

  /// The errors (as strings) encountered while parsing the policy set.
  external ffi.Pointer<ffi.Pointer<ffi.Char>> errors;
}

/// The result of initializing the Cedar policy engine via [cedar_init].
final class CInitResult extends ffi.Struct {
  /// Whether the operation succeeded.
  external ffi.Pointer<CedarStore> store;

  /// The error message, if any.
  ///
  /// Can be `null` to indicate no error.
  external ffi.Pointer<ffi.Char> error;

  /// The length of `error`, if present.
  @ffi.UintPtr()
  external int error_len;
}

final class CCedarConfig extends ffi.Struct {
  /// The Cedar schema, in JSON format.
  ///
  /// Either this or `schema_idl` must be provided.
  external ffi.Pointer<ffi.Char> schema_json;

  /// The Cedar schema, in IDL format.
  ///
  /// Either this or `schema_json` must be provided.
  external ffi.Pointer<ffi.Char> schema_idl;

  /// The Cedar entities, in JSON format.
  ///
  /// Can be `null` to indicate no entities. Entities can be passed individually to [cedar_is_authorized].
  external ffi.Pointer<ffi.Char> entities_json;

  /// The Cedar policies, in JSON format.
  ///
  /// Can be `null` to indicate no policies. Policies can be passed individually to [cedar_is_authorized].
  external ffi.Pointer<ffi.Char> policies_json;

  /// Whether to validate the Cedar policies.
  @ffi.Bool()
  external bool validate;

  /// The log level to use for the Cedar policy engine.
  ///
  /// Must be one of: `OFF`, `ERROR`, `WARN`, `INFO`, `DEBUG`, `TRACE`.
  external ffi.Pointer<ffi.Char> log_level;
}

final class CAuthorizationDecision extends ffi.Struct {
  /// Whether the request is authorized.
  @ffi.Bool()
  external bool is_authorized;

  /// The error message, if any.
  ///
  /// If set, the authorization decision could not be made and no other
  /// fields should be used.
  external ffi.Pointer<ffi.Char> completion_error;

  /// The length of `completion_error`, if present.
  @ffi.UintPtr()
  external int completion_error_len;

  /// The JSON array of reasons.
  ///
  /// Type: `[]string`
  ///
  /// Each entry is a policy ID which contributed to the decision.
  ///
  /// Will be `null` if there are no reasons.
  external ffi.Pointer<ffi.Char> reasons_json;

  /// The length of `reasons_json`, if present.
  @ffi.UintPtr()
  external int reasons_json_len;

  /// The JSON array of errors.
  ///
  /// Type: `[]{ "policy_id": string, "message": string }`
  ///
  /// Each entry is an error that occurred during policy evaluation.
  ///
  /// Will be `null` if there are no errors.
  external ffi.Pointer<ffi.Char> errors_json;

  /// The length of `errors_json`, if present.
  @ffi.UintPtr()
  external int errors_json_len;
}

final class CCedarQuery extends ffi.Struct {
  /// The principal to check authorization for, in entity UID format.
  ///
  /// Can be `null` to indicate an anonymous principal.
  external ffi.Pointer<ffi.Char> principal_str;

  /// The resource to check authorization for, in entity UID format.
  ///
  /// Can be `null` to indicate an anonymous resource.
  external ffi.Pointer<ffi.Char> resource_str;

  /// The action to check authorization for, in entity UID format.
  ///
  /// Can be `null` to indicate an anonymous action.
  external ffi.Pointer<ffi.Char> action_str;

  /// The check's context, if any, in JSON format.
  ///
  /// Can be `null` to indicate no context.
  external ffi.Pointer<ffi.Char> context_json;

  /// The Cedar entities, in JSON format.
  ///
  /// Can be `null` to use the existing entities.
  external ffi.Pointer<ffi.Char> entities_json;

  /// The Cedar policies, in JSON format.
  ///
  /// Can be `null` to use the existing policies.
  external ffi.Pointer<ffi.Char> policies_json;
}
